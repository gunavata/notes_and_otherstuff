<head>
    <title>Algorithms</title>
</head>

<h1>Algorithms</h1>

<h4>Two major types of search algorithms, linear and binary</h4>

<ul>
    <li>
        Linear search - called linear because you query each item</br>
        in a search until you find what you need i.e an array of</br>
        100 items = 100 checks (or a at least until you find what you need)</br>
    </li>
</br>
    <li>
        Binary Search - Split into 2 pairs and continue search inside</br>
        the positive results. Only works with ordered sequences. i.e</br>
        in a row of ordered height people, look for a specific height</br>
        by checking the mid point and cutting off those that fail the</br>
        requirements.</br>
    </li>
</ul>

<h4>Two major types of sorting, Mergesort and quicksort</h4>

<ul>
    <li>
        Mergesort - divide the array into 2 multiple times until you</br>
        come across individuals. Then start comparing each individual</br>
        to each other and order them. Continue the group of 2 to group</br>
        of 4 to group of 8 etc</br>
    </li>
</br>
    <li>
        Quicksort - in an array of numbers, choose a pivot and insert a seperator</br>
        as the first array element. Compare the pivot with the 2nd array element</br>
        if it is smaller, move it behind seperator, else leave it alone.</br>
        Keep doing this until you reach the end of the array. Then repeat for</br>
        first half and 2nd half of the pivot point. For stuff not next to seperator,</br>
        swap that index with the index next to the seperator and then rotate the two.</br>
    </li>
</ul>

<h4>Other algorithms</h4>

<ul>
    <li>
        Heap sort - 
    </li>
</br>
    <li>
        Introsort - 
    </li>
</br>
    <li>
        Insertion sort - 
    </li>
</br>
    <li>
        Bubble/Selection sort - 
    </li>
</br>
    <li>
        Breadth First Search (BFS) - Assuming a pyramid shaped search starting from</br>
        the top, one would search each floor going from one end to another until</br>
        you find what you are looking</br>
    </li>
</br>
    <li>
        Depth First Search - Assuming a pyramid shaped search starting from</br>
        the top, one would take an elevator, searching only the closest room</br>
        and continue the search. The search loops back to the start and looks</br>
        for the next closest room again and follows down the tree</br>
    </li>
</br>
    <li>
        Dynamic Programming (DP) - Breaking down big problems to smaller sub</br>
        problems. The sub problem is solved and saved and the pieces of all</br>
        sub problems is put together to tackle a big problem</br>
    </li>
</br>
    <li>
        Hashing - more used in recent years
    </li>
</br>
    <li>
        String pattern matching - Searching not for an item but a pattern</br>
        common between the items i.e all books that end with a ?</br>
    </li>
</ul>

<h1>Data Structures</h1>

<h4>Trees and graphs</h4>

<ul>
    <li>
        Trees - Similiar to a family tree, depending on the position of a node</br>
        relative to another node, it can be named various things. Storing items</br>
        in a tree allow us to find items in a more efficient way if the tree</br>
        has certain properties</br>
    </li>
</br>
    <li>
        Graphs - ultimately a tree is a special case of a graph.
    </li>
</ul>